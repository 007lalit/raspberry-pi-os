## Raspberry Pi OS project introduction or how to efficiently learn operating system development?

A few years ago I opened the source code of the Linux kernel for the first time.By that time I consider myself more or less skillful software developer, I knew a little bit of assembler and C programming and had a high level understanding of major operating system concepts, such as process scheduling or virtual memory management. But you know what? I understand literally nothing at all. For other complex software projects, that I have to deal with, I have a simple approach that usually works very well for me: I find the entry point of the program and then start reading the source code, going as deep as necessary to understand the programme implementation details. This approach works well, but not with something as difficult as an operating system. It is not only that it took me more than a week just to find an entry point - the main problem is that I quickly find myself in a situation where I am looking at a few lines of code  and I have no idea how to find any clues about what those lines are doing. This is especially true about the low level assembler source code, but it also works the same no matter what part of the system I tried to explore. 

### Challenges in learning OS development.

I know that there are tons of documentation and books, written about linux kernel development, but neither of those provide me with the learning experience that I wanted. One half of the material I was finding too high level and I already new it. With the second half I had very similar problem that I had with the exploring the kernel source code: as soon as book goes deep enough into details 90% of the details appears to be related not to the core concept, but instead to some security, performance or legacy considerations as well as to millions of small features that linux kernel supports. So instead of learning core operating system concepts you always end up digging into implementation  details of those features.

You may be wondering why do I need to learn operating system development at all? For me the main reason is that I was always interested how things works under the hood. And it not just curiosity: the more difficult task you are working on - the more and more often this begins to trace down to operating system level. You simply can't make fully informed  technical decisions if you don't understand how everything works on a lower levels. Another thing is that is you really like technical challenge working with OS development can be a really interesting task for you.

When I told that I had most of the books about linux kernel development didn't work well for me - I wasn't 100% honest. There was one book that I was capable to fully understand even being a novice in OS development and that also explains some important concepts using actual source code. This book is "Linux Device Drivers". It starts with introducing source code of a very simple driver, that you can compile and play around with. Then it starts introducing new driver related concepts one by one  and explains how to modify the source code of the driver to use those concepts. That is exactly what I refer to as "good learning experience". The only problem with this book is that is specifically focuses of driver development and tells very little about specific linux  kernel implementation details.

Wo why did nobody created a similar book but for kernel developers, not device driver authors? I think this is because if you use current linux kernel source code as a base for your book this is simply not possible. There is no place that can works as a simple starting point. You also can't introduce new concepts one at a time because in the source code they are very closely related one to each other. When I realized this an idea came to my mind: if linux kernel is to vast and too complex to use it as a starting point for learning operating system development, why not implement my own OS that is going to be designed specifically for learning purposes. In this way I can make my OS as simple as needed in order to provide a good learning experience. Also if this OS will be implemented just by copying and simplifying different parts of the linux kernel source code it would be very simple to use my simple OS as a starting point to learn linux kernel development.

### OS requirements

So I decided to start working on the project. The first thing I had to do is to define what parts of kernel development I consider "basic" (those parts I was going to include into my kernel) and what parts are not so essential and can be skipped, at least for now. In my understanding each operating system have 2 fundamental goals:

1. Run user processes in isolation.
1. Provide each user process with unified view of the machine hardware.

In order to satisfy the first requirement my OS need to have its own scheduler. If I want to implement scheduler I had to handler timer interrupts. Second requirement implies that my OS is going to suport system calls and support some kind of drivers. From the beginning I don't want to work with complicated hardware, so the only drivers I care about are drivers that can write something to screen and read user input from a keyboard. Also, the OS need to read user program and be able to load and execute it, so obviously it need to support some file system and be able to understand some executable file format. It also would be nice if the OS can support some basic networking, but I don't want to focus on it from the beginning. So that is basically the things that I can name as "core concepts of any operating system". 

Now let's take a look on the things that I want to ignore. 
1. Performance. I don't want to use any sophisticated algorithms. I am going to disable all caches and other performance optimization techniques.
1. Security. It is try that my OS at least one security feature: virtual memory, Everything else can be safely ignored.
1. Multiprocessors and synchronization. I am quite happy with my OS being executed on a single processor core. In particular this allows me to get rid of a huge source of complexity - synchronization. 
1. Support of multiple architectures and devices. More on this in the next section.
1. Millions of other small features that any production ready operating system supports.

### How Raspberry Pi comes into play.

I already mentioned that I don't want my OS to support multiple computer architectures or even multiple devices. This decision become even stronger after I dig into linux kernel driver model. It seems to me that similar devices, that linux kernel support are doing there job sometime in a very different way. This makes it very difficult  to come up with a simple abstractions around similar driver types. To e it seems like one of the main source of complexity in linux kernel and definitely I want to eliminate this in my OS. Ok, but what device should I use then? I definitely don't want to test my bare metal programs using my laptop, because I honestly not sure that it is going to survive. More importantly I don't want people to buy expensive laptop just to follow my os development exercises - I don't think anybody will do this. Emulators looks like more or less good choice, but I wanted to work with a real device, because it gives me different feeling - feeling that I am doing something real rather than playing with bare metal programming.

I ended up by useing raspberry PI, in particular [Raspberry Pi 3 Model B](https://www.raspberrypi.org/products/raspberry-pi-3-model-b/). Using this device looks like an ideal choice for a number of reasons.

1. It cost something around 35$ at the time of writing. I think it should be affordable price even for a student.
1. This device is specially designed for learning. its inner architecture is as simple as possible and that perfectly suits my needs.
1. This device uses ARM v8 architecture. This is simple RISC architecture, it is very well adapted to OS authors needs and it don't have so many legacy requirements as, for example, popular x86 architecture. If you don't believe me you can compare amount of source code in `/arch/arm64` and `/arch/x86` folder in linux kernel.

### Working with community

One major drawback of any technical book that very soon after release each book becomes obsolete. Technology nowadays is evolving so fast that it is almost impossible for book writers to keep up with it. That's why I like the idea of "open source book" - a book that is freely available on the internet and that encourages its readers to participate in content creation and validation. If book content is available on github it makes it very easy for any reader to fix and develop new code samples, update book content and participate in writing new chapters. I understand that right now the project is not perfect and at the time of writing it is even not finished. But I still want to finish it now, because I hope that with the help of the community I will be able not only to finish the project faster but to make it much better and much more useful that it was from the beginning. 

